#*  Copyright (C) 2018 the DEUS contributors.
#*  Website: https://github.com/timjeske/DEUS
#*
#*  This file is part of the KNIME4NGS KNIME extension.
#*
#*  The DEUS R package is free software: you can redistribute it and/or modify
#*  it under the terms of the GNU General Public License as published by
#*  the Free Software Foundation, either version 3 of the License, or
#*  (at your option) any later version.
#*
#*  This program is distributed in the hope that it will be useful,
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#*  GNU General Public License for more details.
#*
#*  You should have received a copy of the GNU General Public License
#*  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' Run differential expression analysis based on DESeq2
#'
#' @param count_table The count table generated by \link[DEUS]{createCountTableFromFastQs}
#' @param pheno_info A data frame with sample identifiers as row names including the columns used for the design formula.
#' The sample identifiers must be identical to those in the count_table.
#' @param design Design formula for differential expression analysis
#' @param out_dir Directory to save sample distance map, PCA and MA plot.
#' @return Returns a list consisting of 'normCounts' and the 'deResult'.
#' 'normCounts' is a data frame of normalized counts with sequences as row names.
#' 'deResult' is a data frame with sequences as row names and the columns 'pvalue', 'padj', 'baseMean', 'log2FoldChange', 'lfcSE', 'stat', 'IHWPval'.
#' See \link[DESeq2]{results} and \link[IHW]{ihw} for further documentation on the columns.
#' @export

runDESeq2 <- function(count_table, pheno_info, design, out_dir=NULL) {
  dds <- DESeq2::DESeqDataSetFromMatrix(count_table = count_table, colData = pheno_info, design = design)
  dds <- dds[rowMeans(DESeq2::counts(dds)) > 1, ]
  dds <- DESeq2::DESeq(dds, betaPrior=TRUE)
  res <- DESeq2::results(dds)
  res <- res[, c(ncol(res)-1, ncol(res), (1:(ncol(res)-2)))]
  res$"IHWPval"=IHW::adj_pvalues(IHW::ihw(res$pvalue~res$baseMean, data=res,alpha=0.1))

  if(!is.null(out_dir)) {
    # plot sample distance
    rld <- DESeq2::rlog(dds, blind=FALSE)
    plotSampleDistanceMap(rld,out_dir)

    # plot PCA
    plotPCA(rld,pheno_info,out_dir)

    # plot MA
    pdf(paste(out_dir,"DESeq2_MAplot_shrunken.pdf",sep="/"), onefile=FALSE)
    DESeq2::plotMA(res, main = "DESeq2", ylim=c(-4,4))
    dev.off()
  }

  counts_norm<-DESeq2::counts(dds, normalized=TRUE)
  newList <- list("normCounts" = counts_norm, "deResult" = as.data.frame(res))
  return(newList)
}

#' Function to plot sample distance map
#'
#' @param rld regularized log transformed counts
#' @param out_dir directory for sample distance map
#' @keywords sample distance map
#' @export

plotSampleDistanceMap <- function(rld, out_dir) {
  pdf(paste(out_dir, "DESeq2_sample_dist.pdf", sep="/"), onefile=FALSE)
  sampleDists <- dist(t(SummarizedExperiment::assay(rld)))
  sampleDistMatrix <- as.matrix(sampleDists)
  rownames(sampleDistMatrix) <- colnames(rld)
  colnames(sampleDistMatrix) <- NULL
  colors <- colorRampPalette( rev(RColorBrewer::brewer.pal(9, "Blues")) )(255)
  pheatmap::pheatmap(sampleDistMatrix,
           clustering_distance_rows=sampleDists,
           clustering_distance_cols=sampleDists,
           col=colors)
  dev.off()
}

#' Function to plot PCA
#'
#' @param rld regularized log transformed counts
#' @param pheno_info data frame with sample names as rownames and assigned condition in first column
#' @param out_dir directory for sample distance map
#' @keywords sample distance map
#' @export

plotPCA <- function(rld, pheno_info, out_dir) {
  mypheno_info <- pheno_info[, !(names(pheno_info) %in% c("sample")), drop=FALSE]
  pdf(paste(out_dir,"DESeq2_PCA.pdf", sep="/"), onefile=FALSE)
  if(ncol(mypheno_info) > 1) {
    data <- DESeq2::plotPCA(rld, intgroup=colnames(mypheno_info), returnData=TRUE)
    percentVar <- round(100 * attr(data, "percentVar"))
    plt <- ggplot(data, aes(PC1, PC2, color=mypheno_info[,1], shape=mypheno_info[,2])) +
      geom_point(size=3) +
      xlab(paste0("PC1: ",percentVar[1],"% variance")) +
      ylab(paste0("PC2: ",percentVar[2],"% variance")) +
      labs(color=colnames(mypheno_info)[1]) +
      labs(shape=colnames(mypheno_info)[2])
  } else {
    plt <- DESeq2::plotPCA(rld, intgroup=colnames(mypheno_info))
  }
  print(plt)
  dev.off()
}
