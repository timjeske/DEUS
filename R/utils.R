#' Function to create a map for row IDs of a data frame
#'
#' This function creates a map for row IDs of its input data frame.
#' In context of the USBseq package the sequence IDs can be used as alternate short identifiers for each unique sequence.
#' @param countTable the table generated by createCountTableFromFastQs
#' @keywords sequence IDs
#' @export
#' @examples
#' in_dir <- system.file("extdata", package = "USBseq")
#' countTable <- createCountTableFromFastQs(in_dir)
#' map <- createMap(countTable)

createMap <- function(countTable) {
  map <- as.data.frame(paste("seq_", c(1:nrow(countTable)) , sep=""))
  row.names(map) <- row.names(countTable)
  names(map) <- c("seq_id")
}

#' Function to filter a count table
#'
#' This function pre-filters a count table of sequences using additional information on sample conditions.
#' Filtering is especially useful in context of the USBseq package because sequence based count tables are generally very large.
#' Sequences are kept if both groups have an average sequence count of at least 10 or if one of both group has zero counts for all samples.
#' @param countTable the table generated by createCountTableFromFastQs
#' @param phenofile path to tab separated file with first column 'sample' and second column 'condition'. Sample IDs must be identical to those in countTable.
#' @keywords filtering
#' @export
#' @examples
#' in_dir <- system.file("extdata", package = "USBseq")
#' countTable <- createCountTableFromFastQs(in_dir)
#' phenofile <- "./my_experiment/condition.tsv"
#' countTableFiltered <- filterLowExp(countTable, phenofile)

filterLowExp<-function(countData,phenofile){
  pheno <- read.table(phenofile, header=T, row.names=1)
  #Get Group Means
  groups <- unique(pheno$condition)
  if(! length(groups) == 2) {
    stop(paste(phenofile," is invalid! Please provide a file with the column 'condition' including two different values."),call.=F)
  }
  for(type in groups){
    cols  <- row.names(pheno)[which(pheno$condition==type)]
    subset <- countData[,cols]
    countData <- cbind(countData,rowMeans(subset))
  }
  #Keep sequences where both groups have an average ReadCount of >10 or one group as no expression
  cond1 = countData[ncol(countData)]>=10 & countData[ncol(countData)-1]>=10
  cond2 = countData[ncol(countData)]==0 & countData[ncol(countData)-1]>1
  cond3 = countData[ncol(countData)]>1 & countData[ncol(countData)-1]==0
  countData = countData[(cond1|cond2|cond3) ,c(1:(ncol(countData)-2))]

  return(countData)
}
