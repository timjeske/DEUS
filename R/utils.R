#' Function to create a map for row IDs of a data frame
#'
#' This function creates a map for row IDs of its input data frame.
#' In context of the USBseq package the sequence IDs can be used as alternate short identifiers for each unique sequence.
#' @param countTable the table generated by createCountTableFromFastQs
#' @keywords sequence IDs
#' @export
#' @examples
#' in_dir <- system.file("extdata", package = "USBseq")
#' countTable <- createCountTableFromFastQs(in_dir)
#' map <- createMap(countTable)

createMap <- function(countTable) {
  map <- as.data.frame(paste("seq_", c(1:nrow(countTable)) , sep=""))
  row.names(map) <- row.names(countTable)
  names(map) <- c("seq_id")
  return(map)
}

#' Function to filter a count table
#'
#' This function pre-filters a count table of sequences using additional information on sample conditions.
#' Filtering is especially useful in context of the USBseq package because sequence based count tables are generally very large.
#' Sequences are kept if both groups have an average sequence count of at least 10 or if one of both group has zero counts for all samples.
#' @param countTable the table generated by createCountTableFromFastQs
#' @param phenofile data frame with sample IDs as row.names and column 'condition'. Sample IDs must be identical to those in countTable.
#' @keywords filtering
#' @export
#' @examples
#' in_dir <- system.file("extdata", package = "USBseq")
#' countTable <- createCountTableFromFastQs(in_dir)
#' phenoInfo <- read.table(system.file("extdata", "condition.tsv", package = "USBseq"), header=T, row.names=1)
#' countTableFiltered <- filterLowExp(countTable, phenoInfo)

filterLowExp<-function(countData,pheno){
  #Get Group Means
  groups <- unique(pheno$condition)
  if(! length(groups) == 2) {
    stop(paste(phenofile," is invalid! Please provide a file with the column 'condition' including two different values."),call.=F)
  }
  for(type in groups){
    cols  <- row.names(pheno)[which(pheno$condition==type)]
    subset <- countData[,cols]
    countData <- cbind(countData,rowMeans(subset))
  }
  #Keep sequences where both groups have an average ReadCount of >10 or one group as no expression
  cond1 = countData[ncol(countData)]>=10 & countData[ncol(countData)-1]>=10
  cond2 = countData[ncol(countData)]==0 & countData[ncol(countData)-1]>1
  cond3 = countData[ncol(countData)]>1 & countData[ncol(countData)-1]==0
  countData = countData[(cond1|cond2|cond3) ,c(1:(ncol(countData)-2))]

  return(countData)
}

#' Function to merge DEA and blast result
#'
#' @param deResult
#' @param blastResult
#' @param map
#' @keywords summary
#' @export
#' @examples

mergeResults <- function(deResult, blastResult, map) {
  blastResult <- blastResult[c("qseqid", "sseqid","length", "evalue")]
  sigResults <- deResult[c(2, 5:ncol(deResult))]
  sigResults$qseqid <- map[row.names(sigResults),1]
  sigResults$sequence <- row.names(sigResults)
  res <- plyr::join(blastResult, sigResults, type = "full")

  group <- data.frame(feature_list=c(by(res$sseqid, res$sequence, function(x)paste(x, collapse=","))))
  group$sequence <- row.names(group)
  group <- plyr::join(group, res, type = "full", match="first")
  group <- group[-which(names(group)=="sseqid")]
  group <- group[,c(which(names(group)!="feature_list"),2)]

  return(group)
}
