#' Function to create a map for row IDs of a data frame
#'
#' This function creates a map for row IDs of its input data frame.
#' In context of the USBseq package the sequence IDs can be used as alternate short identifiers for each unique sequence.
#' @param countTable the table generated by createCountTableFromFastQs
#' @keywords sequence IDs
#' @export
#' @examples
#' in_dir <- system.file("extdata", package = "USBseq")
#' countTable <- createCountTableFromFastQs(in_dir)
#' map <- createMap(countTable)

createMap <- function(countTable) {
  map <- as.data.frame(paste("seq_", c(1:nrow(countTable)) , sep=""))
  row.names(map) <- row.names(countTable)
  names(map) <- c("seq_id")
  return(map)
}

#' Function to filter a count table
#'
#' This function pre-filters a count table of sequences using additional information on sample conditions.
#' Filtering is especially useful in context of the USBseq package because sequence based count tables are generally very large.
#' Sequences are kept if both groups have an average sequence count of at least 10 or if one of both group has zero counts for all samples.
#' @param countTable the table generated by createCountTableFromFastQs
#' @param phenofile data frame with sample IDs as row.names and column 'condition'. Sample IDs must be identical to those in countTable.
#' @keywords filtering
#' @export
#' @examples
#' in_dir <- system.file("extdata", package = "USBseq")
#' countTable <- createCountTableFromFastQs(in_dir)
#' phenoInfo <- read.table(system.file("extdata", "condition.tsv", package = "USBseq"), header=T, row.names=1)
#' countTableFiltered <- filterLowExp(countTable, phenoInfo)

filterLowExp<-function(countData,pheno){
  #Get Group Means
  groups <- unique(pheno$condition)
  if(! length(groups) == 2) {
    stop(paste(phenofile," is invalid! Please provide a file with the column 'condition' including two different values."),call.=F)
  }
  for(type in groups){
    cols  <- row.names(pheno)[which(pheno$condition==type)]
    subset <- countData[,cols]
    countData <- cbind(countData,rowMeans(subset))
  }
  #Keep sequences where both groups have an average ReadCount of >10 or one group as no expression
  cond1 = countData[ncol(countData)]>=10 & countData[ncol(countData)-1]>=10
  cond2 = countData[ncol(countData)]==0 & countData[ncol(countData)-1]>1
  cond3 = countData[ncol(countData)]>1 & countData[ncol(countData)-1]==0
  countData = countData[(cond1|cond2|cond3) ,c(1:(ncol(countData)-2))]

  return(countData)
}

#' Function to merge DEA and blast result
#'
#' @param deResult
#' @param blastResult
#' @param map
#' @keywords summary
#' @export
#' @examples

mergeResults <- function(deResult, blastResult, map) {
  blastResult <- blastResult[c("qseqid", "sseqid", "length", "evalue")]
  sigResults <- deResult[c(2, 5:ncol(deResult))]
  sigResults$qseqid <- map[row.names(sigResults),1]
  sigResults$sequence <- row.names(sigResults)
  res <- plyr::join(blastResult, sigResults, type = "full")

  group <- data.frame(feature_list=c(by(res$sseqid, res$sequence, function(x)paste(x, collapse=","))))
  group$sequence <- row.names(group)
  group <- plyr::join(group, res, type = "full", match="first")
  group <- group[-which(names(group)=="sseqid")]
  group <- group[,c(which(names(group)!="feature_list"),2)]
  group$length <- nchar(group$sequence)
  row.names(group) <- group$sequence
  group <- group[-which(names(group)=="sequence")]
  return(group)
}

#' Function to add counts of different feature classes
#'
#' @param mergedResult
#' @param featureClasses
#' @keywords feature counting
#' @export
#' @examples
#'
addCountsOfFeatureClasses<- function(mergedResult, featureClasses) {
  res <- mergedResult
  v_features <- strsplit(paste(mergedResult$feature_list),",")
  sum <- 0
  for(i in featureClasses) {
    res[i] <- stringr::str_count(string=v_features, i)
    sum <- sum + res[[i]]
  }
  res$"other" <- as.numeric(lapply(v_features, function(x) length(x[! x == "NA" ]))) - sum
  res <- res[,c(which(names(res)!="feature_list"),which(names(res)=="feature_list"))]

  return(res)
}

#' Function to write summary tables and fasta files for USBseq result
#'
#' @param summaryTable
#' @param outDir
#' @keywords summary
#' @export
#' @examples
#'
writeSummaryFiles <- function(summaryTable, outDir) {
  write.table(summaryTable, paste(outDir, "SummaryTable.tsv", sep="/"), sep="\t", quote=F, row.names=T, col.names=T)

  filtered <- summaryTable[!summaryTable$feature_list=="NA",]
  write.table(filtered, paste(outDir, "SummaryTable_withBlast.tsv", sep="/"), sep="\t", quote=F, row.names=T, col.names=T)

  filtered = filtered[filtered$length<36,]
  sequences_withBlast<-paste(paste(">",filtered$qseqid,sep=""),row.names(filtered),sep="\n")
  write.table(sequences_withBlast, paste(out_dir,"SummaryTable_withBlast.35L.fasta",sep="/"),quote=F,row.names=F,col.names=F)

  filtered = summaryTable[summaryTable$feature_list=="NA" | is.na(summaryTable$feature_list),]
  write.table(filtered, paste(out_dir,"SummaryTable_noBlast.tsv",sep="/"), sep="\t", quote=F,row.names=T,col.names=T)

  filtered = filtered[filtered$length<36,]
  sequences_noBlast<-paste(paste(">",filtered$qseqid,sep=""),row.names(filtered),sep="\n")
  write.table(sequences_noBlast, paste(out_dir,"SummaryTable_noBlast.35L.fasta",sep="/"),quote=F,row.names=F,col.names=F)
}
