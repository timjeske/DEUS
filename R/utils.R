#*  Copyright (C) 2018 the DEUS contributors.
#*  Website: https://github.com/timjeske/DEUS
#*
#*  This file is part of the KNIME4NGS KNIME extension.
#*
#*  The DEUS R package is free software: you can redistribute it and/or modify
#*  it under the terms of the GNU General Public License as published by
#*  the Free Software Foundation, either version 3 of the License, or
#*  (at your option) any later version.
#*
#*  This program is distributed in the hope that it will be useful,
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#*  GNU General Public License for more details.
#*
#*  You should have received a copy of the GNU General Public License
#*  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' Create a mapping of sequences to sequence identifiers
#'
#' This function creates a data frame mapping the row names of the input (sequence) count table to sequence identifiers.
#' In context of the DEUS package the sequence identifiers can be used as alternate short identifiers for each unique sequence.
#' @param count_table The count table generated by \link[DEUS]{createCountTableFromFastQs}
#' @return A data frame with sequences as row names and sequence identifiers in the column 'seq_id'
#' @export

createMap <- function(count_table) {
  map <- as.data.frame(paste("seq_", c(1:nrow(count_table)) , sep=""))
  row.names(map) <- row.names(count_table)
  names(map) <- c("seq_id")
  return(map)
}

#' Merge intermediate results of DEUS
#'
#' The function merges results created during DEUS analysis into a comprehensive summary table.
#' It is also possible to merge only a sub-set of all results or to generate the results with other methods than the provided ones.
#'
#' @param de_result Result of differential expression analysis generated by \link[DEUS]{runDESeq2} (columns 'log2FoldChange', 'pvalue' and 'IHWPval' are required)
#' @param count_stats Means and standard deviations of each condition in analysis generated by \link[DEUS]{getConditionCountStats}
#' @param blast_result Result of BLAST generated by \link[DEUS]{runBlast} (columns 'qseqid', 'sseqid', 'length' and 'evalue' are required)
#' @param clust_result Result of clustering generated by \link[DEUS]{runClustering}
#' @param map A data frame with sequences as row names and sequence identifiers in first column.
#' Can be generated by \link[DEUS]{createMap}
#' @return If all results are given, a data frame is created with sequences as row names and the columns 'SequenceID', 'Log2FoldChange', 'Pvalue', 'IHWPvalue', 'NormCounts_<cond1>_Mean', 'NormCounts_<cond1>_Sd', 'NormCounts_<cond2>_Mean', 'NormCounts_<cond2>_Sd', 'ClusterID', 'Length', 'BlastEvalue' and 'FeatureList'.
#' If any result is not given corresponding columns are missing.
#' @export

mergeResults <- function(de_result=NULL, count_stats=NULL, blast_result=NULL, clust_result=NULL, map) {

  if(is.null(de_result) && is.null(count_stats) && is.null(blast_result) && is.null(clust_result)) {
    stop("mergeResults requires at least de_result, count_stats, blast_result or clust_result!")
  }

  res <- map
  colnames(res) <- c("SequenceID")
  res$sequence <- row.names(map)

  if(!is.null(de_result)) {
    sigResults <- de_result[c("log2FoldChange","pvalue","IHWPval")]
    colnames(sigResults) <- c("Log2FoldChange","Pvalue","IHWPvalue")
    sigResults$SequenceID <- map[row.names(sigResults),1]
    sigResults$sequence <- row.names(sigResults)
    res <- sigResults
  }

  if(!is.null(count_stats)) {
    count_stats$sequence <- row.names(count_stats)
    res <- plyr::join(res, count_stats, type = "inner")
  }

  if(!is.null(clust_result)) {
    res <- plyr::join(res, clust_result, type = "full")
  }

  if(!is.null(blast_result)) {
    blast_result <- blast_result[c("qseqid", "sseqid", "length", "evalue")]
    colnames(blast_result) <- c("SequenceID","sseqid","Length","BlastEvalue")
    res <- plyr::join(res, blast_result, type = "full")
    group <- data.frame(FeatureList=c(by(res$sseqid, res$sequence, function(x)paste(x, collapse=","))))
    group$sequence <- row.names(group)
    group <- plyr::join(group, res, type = "full", match="first")
    group <- group[-which(names(group)=="sseqid")]
    # move featureList to last column
    group <- group[,c(which(names(group)!="FeatureList"),which(names(group)=="FeatureList"))]
    # move sequenceID to first column
    group <- group[,c(which(names(group)=="SequenceID"),which(names(group)!="SequenceID"))]
    group$Length <- nchar(group$sequence)
    row.names(group) <- group$sequence
    res <- group[-which(names(group)=="sequence")]
  }

  if("Pvalue" %in% colnames(res)) {
    res <- res[order(res$Pvalue),]
  }
  return(res)
}

#' Compute mean and standard deviation of normalized counts for each condition
#'
#' @param count_table A table of (normalized) sequence counts.
#' A sequence count table can be generated by \link[DEUS]{createCountTableFromFastQs} and normalized by applying \link[DEUS]{runDESeq2}
#' @param pheno_info A data frame with sample names as row names and a column 'condition'
#' @return A data frame with sequences as row names and the mean and standard deviation for each condition defined in pheno_info
#' @export

getConditionCountStats<-function(count_table,pheno_info){

  #get group means
  groups = unique(pheno_info$condition)
  for(type in groups){
    cols  = row.names(pheno_info)[which(pheno_info$condition==type)]
    subset= count_table[,cols]
    count_table=cbind(count_table,rowMeans(subset),data.frame(apply(subset,1,sd)))
    names(count_table)[ncol(count_table)-1]=paste("NormCounts",type,"Mean",sep="_")
    names(count_table)[ncol(count_table)]=paste("NormCounts",type,"Sd",sep="_")
  }
  index=length(groups)*2
  #return only mean & sd columns
  return(count_table[,c((ncol(count_table)-index+1):ncol(count_table))])
}

#' TODO Count occurrences of feature classes given by the user
#'
#' @param mergedResult summary table including blast results
#' @param featureClasses List of features representing classes to be counted.
#' Features can be defined as regular expressions, as described in \link[stringi]{stringi-search-regex}.
#' @keywords feature counting
#' @export

addCountsOfFeatureClasses<- function(mergedResult, featureClasses) {
  if(!("FeatureList" %in% names(mergedResult))) stop('Feature classes can only be counted if blast results have been merged to DE results!')
  res <- mergedResult
  v_features <- strsplit(paste(mergedResult$FeatureList),",")
  sum <- 0
  for(i in featureClasses) {
    #res[i] <- sum(stringr::str_detect(string=v_features[[1]], i))
    tmp_count <- lapply(v_features,stringr::str_detect,pattern=i)
    res[i] <- t(as.data.frame(lapply(tmp_count,sum)))
    sum <- sum + res[[i]]
  }
  res$"Other" <- as.numeric(lapply(v_features, function(x) length(x[! x == "NA" ]))) - sum
  res <- res[,c(which(names(res)!="FeatureList"),which(names(res)=="FeatureList"))]

  if("Pvalue" %in% colnames(res)) {
    res <- res[order(res$Pvalue),]
  }
  return(res)
}

#' TODO Function to write summary tables and fasta files for DEUS result
#'
#' @param summaryTable summary table generated by mergeResults function (requires blast result)
#' @param outDir directory for summary files (tsv tables and fasta files)
#' @keywords summary
#' @export

writeSummaryFiles <- function(summaryTable, outDir) {
  summaryTable$Sequence=row.names(summaryTable)
  summaryTable <- summaryTable[,c(ncol(summaryTable),1:ncol(summaryTable)-1)]
  write.table(summaryTable, paste(outDir, "SummaryTable.tsv", sep="/"), sep="\t", quote=F, row.names=F, col.names=T)

  filtered <- summaryTable[!summaryTable$FeatureList=="NA",]
  write.table(filtered, paste(outDir, "SummaryTable_withBlast.tsv", sep="/"), sep="\t", quote=F, row.names=F, col.names=T)

  filtered = filtered[filtered$Length<36,]
  sequences_withBlast<-paste(paste(">",filtered$SequenceID,sep=""),row.names(filtered),sep="\n")
  write.table(sequences_withBlast, paste(out_dir,"SummaryTable_withBlast.35L.fasta",sep="/"),quote=F,row.names=F,col.names=F)

  filtered = summaryTable[summaryTable$FeatureList=="NA" | is.na(summaryTable$FeatureList),]
  write.table(filtered, paste(out_dir,"SummaryTable_noBlast.tsv",sep="/"), sep="\t", quote=F,row.names=F,col.names=T)

  filtered = filtered[filtered$Length<36,]
  sequences_noBlast<-paste(paste(">",filtered$SequenceID,sep=""),row.names(filtered),sep="\n")
  write.table(sequences_noBlast, paste(out_dir,"SummaryTable_noBlast.35L.fasta",sep="/"),quote=F,row.names=F,col.names=F)
}

#' Create a vector of sequence identifiers and sequences in FASTA format
#'
#' @param de_result A data frame with sequences as row names.
#' In the context of DEUS, the data frame is the resulting table of differential expression analysis with significant sequences as row names.
#' Differential expression analysis can be performed via \link[DEUS]{runDESeq2}
#' @param map A data frame with sequences as row names and sequence identifiers in first column.
#' Can be generated by \link[DEUS]{createMap}
#' @return A vector of alternating sequence identifiers and nucleotide sequences
#' @export

sequencesAsFasta <- function(de_result, map) {
  res <- as.vector(rbind(paste(">",map[row.names(de_result),1],sep=""),row.names(de_result)))
  return(res)
}

#' Remove temporary FASTA file required for clustering
#'
#' This function is internally called by \link[DEUS]{runClustering}
#'
#' @param out_dir Directory where output files of clustering are saved
#' @return Deletes the file sig_sequences.fa
#' @export

deleteTmp <- function(out_dir){
  tmp <- paste(out_dir,"sig_sequences.fa",sep="/")
  if(file.exists(tmp)){
    file.remove(tmp)
  }
}


