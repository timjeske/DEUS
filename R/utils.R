#*  Copyright (C) 2018 the DEUS contributors.
#*  Website: https://github.com/timjeske/DEUS
#*
#*  This file is part of the KNIME4NGS KNIME extension.
#*
#*  The DEUS R package is free software: you can redistribute it and/or modify
#*  it under the terms of the GNU General Public License as published by
#*  the Free Software Foundation, either version 3 of the License, or
#*  (at your option) any later version.
#*
#*  This program is distributed in the hope that it will be useful,
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#*  GNU General Public License for more details.
#*
#*  You should have received a copy of the GNU General Public License
#*  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' Create a mapping of sequences to sequence identifiers
#'
#' This function creates a data frame mapping the row names of the input (sequence) count table to sequence identifiers.
#' In context of the DEUS package the sequence identifiers can be used as alternate short identifiers for each unique sequence.
#' @param count_table The count table generated by \link[DEUS]{createCountTableFromFastQs}
#' @return A data frame with sequences as row names and sequence identifiers in the column 'seq_id'
#' @export

createMap <- function(count_table) {
  map <- as.data.frame(paste("seq_", c(1:nrow(count_table)) , sep=""))
  row.names(map) <- row.names(count_table)
  names(map) <- c("seq_id")
  return(map)
}

#' TODO Function to merge DEA, blast result
#'
#' @param deResult result of differential expression analysis (columns log2FoldChange, pvalue, IHWPval are required)
#' @param countStats result of getConditionCountStats function
#' @param blastResult result of blast function
#' @param clustResult result of clustering function
#' @param map data frame with sequences as row names and sequence IDs in first column
#' @keywords generating summary tables
#' @export

mergeResults <- function(deResult=NULL, countStats=NULL, blastResult=NULL, clustResult=NULL, map) {

  if(is.null(deResult) && is.null(countStats) && is.null(blastResult) && is.null(clustResult)) {
    stop("mergeResults requires at least deResult, countStats, blastResult or clustResult!")
  }

  res <- map
  colnames(res) <- c("SequenceID")
  res$sequence <- row.names(map)

  if(!is.null(deResult)) {
    sigResults <- deResult[c("log2FoldChange","pvalue","IHWPval")]
    colnames(sigResults) <- c("Log2FoldChange","Pvalue","IHWPvalue")
    sigResults$SequenceID <- map[row.names(sigResults),1]
    sigResults$sequence <- row.names(sigResults)
    res <- sigResults
  }

  if(!is.null(countStats)) {
    countStats$sequence <- row.names(countStats)
    res <- plyr::join(res, countStats, type = "inner")
  }

  if(!is.null(clustResult)) {
    res <- plyr::join(res, clustResult, type = "full")
  }

  if(!is.null(blastResult)) {
    blastResult <- blastResult[c("qseqid", "sseqid", "length", "evalue")]
    colnames(blastResult) <- c("SequenceID","sseqid","Length","BlastEvalue")
    res <- plyr::join(res, blastResult, type = "full")
    group <- data.frame(FeatureList=c(by(res$sseqid, res$sequence, function(x)paste(x, collapse=","))))
    group$sequence <- row.names(group)
    group <- plyr::join(group, res, type = "full", match="first")
    group <- group[-which(names(group)=="sseqid")]
    # move featureList to last column
    group <- group[,c(which(names(group)!="FeatureList"),which(names(group)=="FeatureList"))]
    # move sequenceID to first column
    group <- group[,c(which(names(group)=="SequenceID"),which(names(group)!="SequenceID"))]
    group$Length <- nchar(group$sequence)
    row.names(group) <- group$sequence
    res <- group[-which(names(group)=="sequence")]
  }

  if("Pvalue" %in% colnames(res)) {
    res <- res[order(res$Pvalue),]
  }
  return(res)
}

#' Compute mean and standard deviation of normalized counts for each condition
#'
#' @param count_table A table of (normalized) sequence counts.
#' A sequence count table can be generated by \link[DEUS]{createCountTableFromFastQs} and normalized by applying \link[DEUS]{runDESeq2}
#' @param pheno_info A data frame with sample names as row names and a column 'condition'
#' @return A data frame with sequences as row names and the mean and standard deviation for each condition defined in pheno_info
#' @export

getConditionCountStats<-function(count_table,pheno_info){

  #get group means
  groups = unique(pheno_info$condition)
  for(type in groups){
    cols  = row.names(pheno_info)[which(pheno_info$condition==type)]
    subset= count_table[,cols]
    count_table=cbind(count_table,rowMeans(subset),data.frame(apply(subset,1,sd)))
    names(count_table)[ncol(count_table)-1]=paste("NormCounts",type,"Mean",sep="_")
    names(count_table)[ncol(count_table)]=paste("NormCounts",type,"Sd",sep="_")
  }
  index=length(groups)*2
  #return only mean & sd columns
  return(count_table[,c((ncol(count_table)-index+1):ncol(count_table))])
}

#' TODO Function to add counts of different feature classes
#'
#' @param mergedResult summary table including blast results
#' @param featureClasses List of features representing classes to be counted.
#' Features can be defined as regular expressions, as described in \link[stringi]{stringi-search-regex}.
#' @keywords feature counting
#' @export

addCountsOfFeatureClasses<- function(mergedResult, featureClasses) {
  if(!("FeatureList" %in% names(mergedResult))) stop('Feature classes can only be counted if blast results have been merged to DE results!')
  res <- mergedResult
  v_features <- strsplit(paste(mergedResult$FeatureList),",")
  sum <- 0
  for(i in featureClasses) {
    #res[i] <- sum(stringr::str_detect(string=v_features[[1]], i))
    tmp_count <- lapply(v_features,stringr::str_detect,pattern=i)
    res[i] <- t(as.data.frame(lapply(tmp_count,sum)))
    sum <- sum + res[[i]]
  }
  res$"Other" <- as.numeric(lapply(v_features, function(x) length(x[! x == "NA" ]))) - sum
  res <- res[,c(which(names(res)!="FeatureList"),which(names(res)=="FeatureList"))]

  if("Pvalue" %in% colnames(res)) {
    res <- res[order(res$Pvalue),]
  }
  return(res)
}

#' TODO Function to write summary tables and fasta files for DEUS result
#'
#' @param summaryTable summary table generated by mergeResults function (requires blast result)
#' @param outDir directory for summary files (tsv tables and fasta files)
#' @keywords summary
#' @export

writeSummaryFiles <- function(summaryTable, outDir) {
  summaryTable$Sequence=row.names(summaryTable)
  summaryTable <- summaryTable[,c(ncol(summaryTable),1:ncol(summaryTable)-1)]
  write.table(summaryTable, paste(outDir, "SummaryTable.tsv", sep="/"), sep="\t", quote=F, row.names=F, col.names=T)

  filtered <- summaryTable[!summaryTable$FeatureList=="NA",]
  write.table(filtered, paste(outDir, "SummaryTable_withBlast.tsv", sep="/"), sep="\t", quote=F, row.names=F, col.names=T)

  filtered = filtered[filtered$Length<36,]
  sequences_withBlast<-paste(paste(">",filtered$SequenceID,sep=""),row.names(filtered),sep="\n")
  write.table(sequences_withBlast, paste(out_dir,"SummaryTable_withBlast.35L.fasta",sep="/"),quote=F,row.names=F,col.names=F)

  filtered = summaryTable[summaryTable$FeatureList=="NA" | is.na(summaryTable$FeatureList),]
  write.table(filtered, paste(out_dir,"SummaryTable_noBlast.tsv",sep="/"), sep="\t", quote=F,row.names=F,col.names=T)

  filtered = filtered[filtered$Length<36,]
  sequences_noBlast<-paste(paste(">",filtered$SequenceID,sep=""),row.names(filtered),sep="\n")
  write.table(sequences_noBlast, paste(out_dir,"SummaryTable_noBlast.35L.fasta",sep="/"),quote=F,row.names=F,col.names=F)
}

#' Create a vector of sequence identifiers and sequences in FASTA format
#'
#' @param de_result A data frame with sequences as row names.
#' In the context of DEUS, the data frame is the resulting table of differential expression analysis with significant sequences as row names.
#' Differential expression analysis can be performed via \link[DEUS]{runDESeq2}
#' @param map A data frame with sequences as row names and sequence identifiers in first column.
#' Can be generated by \link[DEUS]{createMap}
#' @return A vector of alternating sequence identifiers and nucleotide sequences
#' @export

sequencesAsFasta <- function(de_result, map) {
  res <- as.vector(rbind(paste(">",map[row.names(de_result),1],sep=""),row.names(de_result)))
  return(res)
}

#' TODO Function to remove temporary files after pipeline execution
#'
#' @param outDir output folder
#' @export

deleteTmp <- function(outDir){
  tmp <- paste(out_dir,"sig_sequences.fa",sep="/")
  if(file.exists(tmp)){
    file.remove(tmp)
  }
}


