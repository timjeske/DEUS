#*  Copyright (C) 2018 the DEUS contributors.
#*  Website: https://github.com/timjeske/DEUS
#*
#*  This file is part of the DEUS R package.
#*
#*  The DEUS R package is free software: you can redistribute it and/or modify
#*  it under the terms of the GNU General Public License as published by
#*  the Free Software Foundation, either version 3 of the License, or
#*  (at your option) any later version.
#*
#*  This program is distributed in the hope that it will be useful,
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#*  GNU General Public License for more details.
#*
#*  You should have received a copy of the GNU General Public License
#*  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' Create a mapping of sequences to sequence identifiers
#'
#' This function creates a data frame mapping the row names of the input (sequence) count table to sequence identifiers.
#' In context of the DEUS package the sequence identifiers can be used as alternate short identifiers for each unique sequence.
#' @param count_table The count table generated by \link[DEUS]{createCountTableFromFastQs}
#' @return A data frame with sequences as row names and sequence identifiers in the column 'seq_id'
#' @export

createMap <- function(count_table) {
  map <- as.data.frame(paste("seq_", c(1:nrow(count_table)) , sep=""))
  row.names(map) <- row.names(count_table)
  names(map) <- c("seq_id")
  return(map)
}

#' Merge intermediate results of DEUS
#'
#' The function merges results created during DEUS analysis into a comprehensive summary table.
#' It is also possible to merge only a sub-set of all results or to generate the results with other methods than the provided ones.
#'
#' @param de_result Result of differential expression analysis generated by \link[DEUS]{runDESeq2} (columns 'log2FoldChange', 'pvalue' and 'IHWPval' are required)
#' @param count_stats Means and standard deviations of each condition in analysis generated by \link[DEUS]{getConditionCountStats}
#' @param blast_result Result of BLAST generated by \link[DEUS]{runBlast} (columns 'qseqid', 'sseqid', 'length' and 'evalue' are required)
#' @param clust_result Result of clustering generated by \link[DEUS]{runClustering}
#' @param map A data frame with sequences as row names and sequence identifiers in first column.
#' Can be generated by \link[DEUS]{createMap}
#' @return If all results are given, a data frame is created with sequences as row names and the columns 'SequenceID', 'Log2FoldChange', 'Pvalue', 'IHWPvalue', 'NormCounts_<cond1>_Mean', 'NormCounts_<cond1>_Sd', 'NormCounts_<cond2>_Mean', 'NormCounts_<cond2>_Sd', 'ClusterID', 'Length', 'BlastEvalue' and 'FeatureList'.
#' If any result is not given corresponding columns are missing.
#' @export

mergeResults <- function(de_result=NULL, count_stats=NULL, blast_result=NULL, clust_result=NULL, map) {

  if(is.null(de_result) && is.null(count_stats) && is.null(blast_result) && is.null(clust_result)) {
    stop("mergeResults requires at least de_result, count_stats, blast_result or clust_result!")
  }

  res <- map
  colnames(res) <- c("SequenceID")
  res$sequence <- row.names(map)

  if(!is.null(de_result)) {

    #test if Cluster cols exist
    if("Cl_IHWPval" %in% colnames(de_result)){
      sigResults <- de_result[c("log2FoldChange","pvalue","IHWPval","Cl_log2FoldChange","Cl_pvalue","Cl_IHWPval")]
      colnames(sigResults) <- c("Log2FoldChange","Pvalue","IHWPvalue","Cl_Log2FoldChange","Cl_Pvalue","Cl_IHWPvalue")
    }else{
      sigResults <- de_result[c("log2FoldChange","pvalue","IHWPval")]
      colnames(sigResults) <- c("Log2FoldChange","Pvalue","IHWPvalue")
    }

    sigResults$SequenceID <- map[row.names(sigResults),1]
    sigResults$sequence <- row.names(sigResults)
    res <- sigResults
  }

  if(!is.null(count_stats)) {
    count_stats$sequence <- row.names(count_stats)
    res <- plyr::join(res, count_stats, type = "left")
  }

  if(!is.null(clust_result)) {
    res <- plyr::join(res, clust_result, type = "left")
  }

  if(!is.null(blast_result)) {
    blast_result <- blast_result[c("qseqid", "sseqid", "length", "evalue")]
    colnames(blast_result) <- c("SequenceID","sseqid","Length","BlastEvalue")
    res <- plyr::join(res, blast_result, type = "left")
    group <- data.frame(FeatureList=c(by(res$sseqid, res$sequence, function(x)paste(x, collapse=","))))
    group$sequence <- row.names(group)
    group <- plyr::join(group, res, type = "full", match="first")
    group <- group[-which(names(group)=="sseqid")]
    # move featureList to last column
    group <- group[,c(which(names(group)!="FeatureList"),which(names(group)=="FeatureList"))]
    # move sequenceID to first column
    group <- group[,c(which(names(group)=="SequenceID"),which(names(group)!="SequenceID"))]
    group$Length <- nchar(group$sequence)
    row.names(group) <- group$sequence
    res <- group[-which(names(group)=="sequence")]
  }

  if("Pvalue" %in% colnames(res)) {
    res <- res[order(res$Pvalue),]
  }
  return(res)
}

#' Compute mean and standard deviation of normalized counts for each condition
#'
#' @param count_table A table of (normalized) sequence counts.
#' A sequence count table can be generated by \link[DEUS]{createCountTableFromFastQs} and normalized by applying \link[DEUS]{runDESeq2}
#' @param pheno_info A data frame with sample names as row names and a column 'condition'
#' @return A data frame with sequences as row names and the mean and standard deviation for each condition defined in pheno_info
#' @export

getConditionCountStats<-function(count_table,pheno_info){

  #get group means
  groups = unique(pheno_info$condition)
  for(type in groups){
    cols  = row.names(pheno_info)[which(pheno_info$condition==type)]
    subset= count_table[,cols]
    count_table=cbind(count_table,rowMeans(subset),data.frame(apply(subset,1,sd)))
    names(count_table)[ncol(count_table)-1]=paste("NormCounts",type,"Mean",sep="_")
    names(count_table)[ncol(count_table)]=paste("NormCounts",type,"Sd",sep="_")
  }
  index=length(groups)*2
  #return only mean & sd columns
  return(count_table[,c((ncol(count_table)-index+1):ncol(count_table))])
}

#' Count occurrences of feature classes
#'
#' As each unique sequence can have a lot of BLAST hits this function counts the number of hits grouped by user defined feature classes.
#'
#' @param summary Summary table generated by \link[DEUS]{mergeResults} (requires BLAST result generated by \link[DEUS]{runBlast})
#' @param feature_classes List of features representing classes to be counted.
#' Features can be defined as regular expressions, as described in \link[stringi]{stringi-search-regex}.
#' @return The summary table with additional columns for each feature term given by the user.
#' Each column holds the number of features in 'FeatureList' that match the corresponding feature term.
#' The column 'Other' reflects the number of all features in the 'FeatureList' after substracting the sum of feature class matches.
#' @export

addCountsOfFeatureClasses<- function(summary, feature_classes) {
  if(!("FeatureList" %in% names(summary))) stop('Feature classes can only be counted if blast results have been merged to DE results!')
  res <- summary
  v_features <- strsplit(paste(summary$FeatureList),",")
  sum <- 0
  for(i in feature_classes) {
    #res[i] <- sum(stringr::str_detect(string=v_features[[1]], i))
    tmp_count <- lapply(v_features,stringr::str_detect,pattern=i)
    res[i] <- t(as.data.frame(lapply(tmp_count,sum)))
    sum <- sum + res[[i]]
  }
  res$"Other" <- as.numeric(lapply(v_features, function(x) length(x[! x == "NA" ]))) - sum
  res <- res[,c(which(names(res)!="FeatureList"),which(names(res)=="FeatureList"))]

  if("Pvalue" %in% colnames(res)) {
    res <- res[order(res$Pvalue),]
  }
  return(res)
}

#' Write summary tables for DEUS result
#'
#' @param summary Summary table generated by \link[DEUS]{mergeResults} (requires BLAST result generated by \link[DEUS]{runBlast})
#' @param out_dir Directory where summary tables are written
#' @return Files are written to the output directory. 'SummaryTable.tsv' corresponds to the table generated by \link[DEUS]{mergeResults}.
#' The table is split into a file 'SummaryTable_withBlast.tsv' and a file 'SummaryTable_noBlast.tsv' representing the sequences that have a BLAST hit and those with no BLAST hit.
#' @export

writeSummaryFiles <- function(summary, out_dir, expressedOnly=TRUE) {

  #Remove lines without IHWPvalue. Indicates that sequence expression is below cutoff used during DE analysis
  if(expressedOnly==TRUE){
    summary <- summary[!is.na(summary$IHWPvalue),]
  }

  summary$Sequence <- row.names(summary)
  summary <- summary[,c(ncol(summary),1:ncol(summary)-1)]
  write.table(summary, paste(out_dir, "SummaryTable.tsv", sep="/"), sep="\t", quote=F, row.names=F, col.names=T)

  filtered <- summary[!summary$FeatureList=="NA",]
  write.table(filtered, paste(out_dir, "SummaryTable_withBlast.tsv", sep="/"), sep="\t", quote=F, row.names=F, col.names=T)

  filtered <- summary[summary$FeatureList=="NA" | is.na(summary$FeatureList),]
  write.table(filtered, paste(out_dir,"SummaryTable_noBlast.tsv",sep="/"), sep="\t", quote=F,row.names=F,col.names=T)

}

#' Create a vector of sequence identifiers and sequences in FASTA format
#'
#' @param de_result A data frame with sequences as row names.
#' In the context of DEUS, the data frame is the resulting table of differential expression analysis with significant sequences as row names.
#' Differential expression analysis can be performed via \link[DEUS]{runDESeq2}
#' @param map A data frame with sequences as row names and sequence identifiers in first column.
#' Can be generated by \link[DEUS]{createMap}
#' @return A vector of alternating sequence identifiers and nucleotide sequences
#' @export

sequencesAsFasta <- function(de_result, map) {
  res <- as.vector(rbind(paste(">",map[row.names(de_result),1],sep=""),row.names(de_result)))
  return(res)
}

#' Remove temporary FASTA file required for clustering
#'
#' This function is internally called by \link[DEUS]{runClustering}
#'
#' @param out_dir Directory where output files of clustering are saved
#' @return Deletes the file sig_sequences.fa
#' @export

deleteTmp <- function(out_dir){
  tmp <- paste(out_dir,"sig_sequences.fa",sep="/")
  if(file.exists(tmp)){
    file.remove(tmp)
  }
}


merge_and_aggregate <- function(map,cl_count_table,clustResult){
  #Add seq_id
  cl_count_table$"SequenceID" <- map[row.names(cl_count_table),]

  #Add ClusterID
  cl_count_table <- plyr::join(cl_count_table,clustResult)

  #Remove extra cols before aggregation
  cl_count_table <- cl_count_table[ , -which(names(cl_count_table) %in% c("SequenceID"))]

  #Sum counts by cluster
  cl_counts <- aggregate(cl_count_table[-(ncol(cl_count_table))], by=list(Category=cl_count_table$ClusterID), FUN=sum)

  #Rownames indicate ClusterID
  row.names(cl_counts) <- cl_counts$Category
  cl_counts <- cl_counts[ , -which(names(cl_counts) %in% c("Category"))]

  return(cl_counts)
}

merge_single_and_cluster_results <- function(cl_sigResults,clustResult,sigResults,map){
  #Adjust map to work here
  map$sequences <- row.names(map)
  names(map)[1]="SequenceID"

  #combine cl_deseq and clustering results
  cl_sigResults <- plyr::join(cl_sigResults,clustResult,type="inner",by="ClusterID")

  #Combine both deseq results
  sigResults$"SequenceID" <- map[row.names(sigResults),"SequenceID"]
  sigResults <- plyr::join(sigResults,cl_sigResults,type="full",by="SequenceID")

  #Add sequence as row name
  sigResults <- plyr::join(sigResults,map,type="inner",by="SequenceID")
  rownames(sigResults) <- sigResults$sequences
  sigResults <- sigResults[ , -which(names(sigResults) %in% c("sequences"))]

  return(sigResults)
}
