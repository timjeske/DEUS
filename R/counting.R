#*  Copyright (C) 2018 the DEUS contributors.
#*  Website: https://github.com/timjeske/DEUS
#*
#*  This file is part of the DEUS R package.
#*
#*  The DEUS R package is free software: you can redistribute it and/or modify
#*  it under the terms of the GNU General Public License as published by
#*  the Free Software Foundation, either version 3 of the License, or
#*  (at your option) any later version.
#*
#*  This program is distributed in the hope that it will be useful,
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#*  GNU General Public License for more details.
#*
#*  You should have received a copy of the GNU General Public License
#*  along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' Create sequence-based count tables
#'
#' This function creates count tables summarizing counts for each observed sequence in a set of fastQ files.
#' Input files are taken from the given input directory and are selected based on the given fastQ suffix.
#' @param in_dir Input directory containing fastQ files to be analyzed
#' @param fq_suffix Suffix of your fastq files, default is ".fq.gz"
#' @param pheno_info A data frame with sample names as row names and file names in column 'sample'.
#' The sample names will be used as headers in the count table.
#' If not given the file names of the fastQ files count table will be the headers of the count table.
#' @return A data frame with unique sequences as row names and the correspoding number of occurrences for each sample
#' @export

createCountTableFromFastQs <- function(in_dir,fq_suffix = ".fq.gz",pheno_info=NULL) {
  file.list <- list.files(in_dir)
  fastqs <- file.list[endsWith(file.list,fq_suffix)]
  fastqs <- paste(in_dir,fastqs,sep="/")

  if(!is.null(pheno_info) && "sample" %in% colnames(pheno_info)) {
    pheno_info$sampleName = rownames(pheno_info)
    pheno_info$baseName = basename(as.character(pheno_info$sample))
    fastqs <- paste(in_dir, pheno_info$baseName, sep="/")
  }

  print(paste("Counting all reads in",fastqs[1]))
  content <- ShortRead::readFastq(fastqs[1])
  counts <- ShortRead::tables(content,n=length(content))
  countTable <- as.data.frame(counts$top)
  names(countTable) <- c(basename(fastqs[1]))

  if(!is.null(pheno_info) && "sample" %in% colnames(pheno_info)) {
    names(countTable) <- c(as.character(pheno_info$sampleName[basename(fastqs[1])==pheno_info$baseName]))
  }

  countTable$Read <- row.names(countTable)
  fastqs <- fastqs[-1]
  for(f in fastqs) {
    print(paste("Counting all reads in",f))
    content <- ShortRead::readFastq(f)
    counts <- ShortRead::tables(content,n=length(content))
    counts <- as.data.frame(counts$top)
    names(counts) <- c(basename(f))
    if(!is.null(pheno_info) && "sample" %in% colnames(pheno_info)) {
      names(counts) <- c(as.character(pheno_info$sampleName[basename(f)==pheno_info$baseName]))
    }
    counts$Read <- row.names(counts)
    countTable <- plyr::join(countTable, counts, type="full")
  }
  row.names(countTable) <- countTable$Read
  countTable$Read <- NULL
  countTable[is.na(countTable)] <- 0
  return(countTable)
}

#' Filter a count table
#'
#' This function filters a table of (sequence) counts using additional information on sample conditions.
#' Filtering is especially useful in context of the DEUS package because sequence based count tables are generally very large.
#' Sequences are kept if both groups have a default minimum average sequence count of 10 or if one of both groups has zero counts for all samples.
#' @param count_table The count table generated by \link[DEUS]{createCountTableFromFastQs}
#' @param pheno_info A data frame with sample identifiers as row names including the column 'condition'.
#' The sample identifiers must be identical to those in the count_table.
#' @param group_threshold Minimum average sequence count for both groups
#' @return The input count table with all sequences removed that fail the filter critera
#' @export

filterLowExp<-function(count_table,pheno_info, group_threshold = 10){
  #Get Group Means
  groups <- unique(pheno_info$condition)
  if(! length(groups) == 2) {
    stop(paste(pheno_info," is invalid! Please provide a data frame with the column 'condition' including two different values."),call.=F)
  }
  for(type in groups){
    cols  <- row.names(pheno_info)[which(pheno_info$condition==type)]
    subset <- count_table[,cols]
    count_table <- cbind(count_table,rowMeans(subset))
  }
  #Keep sequences where both groups have an average ReadCount of >10 or one group as no expression
  cond1 = count_table[ncol(count_table)]>=group_threshold & count_table[ncol(count_table)-1]>=group_threshold
  cond2 = count_table[ncol(count_table)]==0 & count_table[ncol(count_table)-1]>1
  cond3 = count_table[ncol(count_table)]>1 & count_table[ncol(count_table)-1]==0
  count_table = count_table[(cond1|cond2|cond3) ,c(1:(ncol(count_table)-2))]

  return(count_table)
}
